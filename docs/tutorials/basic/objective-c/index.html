<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="https://cjyabraham.github.io/css/style.css">
    <title>
  gRPC Basics - Objective-C &ndash; gRPC
</title>
  </head>
  <body>

    <div id="landing-content">
      <div class="row">
        <div class="topbannersub">

	  <nav class="navbar navbar-expand-md navbar-dark topnav">
            <a class="navbar-brand" href="https://cjyabraham.github.io/">
                <img src="https://cjyabraham.github.io/img/grpc-logo.png" width="114" height="50">
            </a>
	    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
	      <span class="navbar-toggler-icon"></span>
	    </button>
            <div class="topnav, collapse navbar-collapse" id="navbarSupportedContent">
	      <ul class="navbar-nav mr-auto">
                <li class="nav-item ">
		  <a class="nav-link" href="https://cjyabraham.github.io/about/">About</a>
		</li>
                <li class="nav-item dropdown active">
		  <a class="nav-link dropdown-toggle" href="https://cjyabraham.github.io/docs/" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
		    Docs
		  </a>
		  <div class="dropdown-menu" aria-labelledby="navbarDropdown">
		    <a class="dropdown-item" href="https://cjyabraham.github.io/docs/">Overview</a>
		    <a class="dropdown-item" href="https://cjyabraham.github.io/docs/quickstart/">Quick Start</a>
		    <a class="dropdown-item" href="https://cjyabraham.github.io/docs/guides/">Guides</a>
		    <a class="dropdown-item" href="https://cjyabraham.github.io/docs/tutorials/">Tutorials</a>
		    <a class="dropdown-item" href="https://cjyabraham.github.io/docs/reference/">Reference</a>
		    <a class="dropdown-item" href="https://cjyabraham.github.io/docs/samples/">Samples</a>
		    <a class="dropdown-item" href="https://cjyabraham.github.io/docs/talks/">Presentations</a>
		  </div>
		</li>
                <li class="nav-item ">
		  <a class="nav-link" href="https://cjyabraham.github.io/blog/">Blog</a> 
		</li>
                <li class="nav-item ">
		  <a class="nav-link" href="https://cjyabraham.github.io/community/">Community</a>
		</li>
                <li class="nav-item">
		  <a class="nav-link" href="https://packages.grpc.io/">Packages</a> 
		</li>
                <li class="nav-item ">
		  <a class="nav-link" href="https://cjyabraham.github.io/faq/">FAQ</a>
		</li>
	      </ul>
            </div>
	  </nav>
    
            <div class="headertext">Documentation</div>
  </div>
        </div>
        </div>

    <div class="subnav d-none d-md-block">
  <a href="https://cjyabraham.github.io/docs/">Overview</a>
|  <a href="https://cjyabraham.github.io/docs/quickstart/">Quick Start</a>
|  <a href="https://cjyabraham.github.io/docs/guides/">Guides</a>
|  <a href="https://cjyabraham.github.io/docs/tutorials/">+Tutorials</a>
|  <a href="https://cjyabraham.github.io/docs/reference/">Reference</a>
|  <a href="https://cjyabraham.github.io/docs/samples/">Samples</a>
|  <a href="https://cjyabraham.github.io/docs/talks/">Presentations</a>
</div>


<div class="quickstartcols">          

<div class="quickstartcol1">

Tutorials<br>
<a href="https://cjyabraham.github.io/docs/tutorials/async/helloasync-cpp/">Async - C++</a><br>
<a href="https://cjyabraham.github.io/docs/tutorials/auth/oauth2-objective-c/">Auth - Objective C</a><br>
Basic <br>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/c/">C++</a><br>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/csharp/">C#</a><br>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/dart/">Dart</a><br>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/go/">Go</a><br>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/java/">Java</a><br>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/android/">Android Java</a><br>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/objective-c/">+Objective-C</a><br>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/php/">PHP</a><br>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/python/">Python</a><br>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/ruby/">Ruby</a><br>

</div>

<div class="quickstartcol2" style="margin-top:4%">
<h3 style="margin-top:0px;">gRPC Basics - Objective-C</h3>

    

<p class="lead">This tutorial provides a basic Objective-C programmer's
introduction to working with gRPC.</p>

<p>By walking through this example you&rsquo;ll learn how to:</p>

<ul>
<li>Define a service in a .proto file.</li>
<li>Generate client code using the protocol buffer compiler.</li>
<li>Use the Objective-C gRPC API to write a simple client for your service.</li>
</ul>

<p>It assumes a passing familiarity with <a href="https://developers.google.com/protocol-buffers/docs/overview">protocol
buffers</a>. Note
that the example in this tutorial uses the proto3 version of the protocol
buffers language, which is currently in beta release: you can find out more in
the <a href="https://developers.google.com/protocol-buffers/docs/proto3">proto3 language
guide</a> and the
<a href="https://developers.google.com/protocol-buffers/docs/reference/objective-c-generated">Objective-C generated code
guide</a>,
and see the <a href="https://github.com/google/protobuf/releases">release notes</a> for the
new version in the protocol buffers Github repository.</p>

<div id="toc"></div>

<p><a name="why-grpc"></a></p>

<h2 id="why-use-grpc">Why use gRPC?</h2>

<p>With gRPC you can define your service once in a .proto file and implement
clients and servers in any of gRPC&rsquo;s supported languages, which in turn can be
run in environments ranging from servers inside Google to your own tablet - all
the complexity of communication between different languages and environments is
handled for you by gRPC. You also get all the advantages of working with
protocol buffers, including efficient serialization, a simple IDL, and easy
interface updating.</p>

<p>gRPC and proto3 are specially suited for mobile clients: gRPC is implemented on
top of HTTP/2, which results in network bandwidth savings over using HTTP/1.1.
Serialization and parsing of the proto binary format is more efficient than the
equivalent JSON, resulting in CPU and battery savings. And proto3 uses a runtime
that has been optimized over the years at Google to keep code size to a minimum.
The latter is important in Objective-C, because the ability of the compiler to
strip unused code is limited by the dynamic nature of the language.</p>

<p><a name="setup"></a></p>

<h2 id="example-code-and-setup">Example code and setup</h2>

<p>The example code for our tutorial is in
<a href="https://github.com/grpc/grpc/tree/{{ site.data.config.grpc_release_tag }}/examples/objective-c/route_guide">grpc/grpc/examples/objective-c/route_guide</a>.
To download the example, clone the <code>grpc</code> repository by running the following
commands:</p>

<pre><code>$ git clone -b {{ site.data.config.grpc_release_tag }} https://github.com/grpc/grpc
$ cd grpc
$ git submodule update --init
</code></pre>

<p>Then change your current directory to <code>examples/objective-c/route_guide</code>:</p>

<pre><code>$ cd examples/objective-c/route_guide
</code></pre>

<p>Our example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.</p>

<p>You also should have <a href="https://cocoapods.org/#install">Cocoapods</a> installed, as
well as the relevant tools to generate the client library code (and a server in
another language, for testing). You can obtain the latter by following <a href="https://github.com/grpc/homebrew-grpc">these
setup instructions</a>.</p>

<p><a name="try"></a></p>

<h2 id="try-it-out">Try it out!</h2>

<p>To try the sample app, we need a gRPC server running locally. Let&rsquo;s compile and
run, for example, the C++ server in this repository:</p>

<pre><code>$ pushd ../../cpp/route_guide
$ make
$ ./route_guide_server &amp;
$ popd
</code></pre>

<p>Now have Cocoapods generate and install the client library for our .proto files:</p>

<pre><code>$ pod install
</code></pre>

<p>(This might have to compile OpenSSL, which takes around 15 minutes if Cocoapods
doesn&rsquo;t have it yet on your computer&rsquo;s cache).</p>

<p>Finally, open the XCode workspace created by Cocoapods, and run the app. You can
check the calling code in <code>ViewControllers.m</code> and see the results in XCode&rsquo;s log
console.</p>

<p>The next sections guide you step-by-step through how this proto service is
defined, how to generate a client library from it, and how to create an app that
uses that library.</p>

<p><a name="proto"></a></p>

<h2 id="defining-the-service">Defining the service</h2>

<p>First let&rsquo;s look at how the service we&rsquo;re using is defined. A gRPC <em>service</em> and
its method <em>request</em> and <em>response</em> types using <a href="https://developers.google.com/protocol-buffers/docs/overview">protocol
buffers</a>. You can
see the complete .proto file for our example in
<a href="https://github.com/grpc/grpc/blob/{{ site.data.config.grpc_release_tag }}/examples/protos/route_guide.proto"><code>examples/protos/route_guide.proto</code></a>.</p>

<p>To define a service, you specify a named <code>service</code> in your .proto file:</p>

<pre><code class="language-protobuf">service RouteGuide {
   ...
}
</code></pre>

<p>Then you define <code>rpc</code> methods inside your service definition, specifying their
request and response types. Protocol buffers let you define four kinds of
service method, all of which are used in the <code>RouteGuide</code> service:</p>

<ul>
<li>A <em>simple RPC</em> where the client sends a request to the server and receives a
response later, just like a normal remote procedure call.</li>
</ul>

<pre><code class="language-protobuf">// Obtains the feature at a given position.
rpc GetFeature(Point) returns (Feature) {}
</code></pre>

<ul>
<li>A <em>response-streaming RPC</em> where the client sends a request to the server and
gets back a stream of response messages. You specify a response-streaming
method by placing the <code>stream</code> keyword before the <em>response</em> type.</li>
</ul>

<pre><code class="language-protobuf">// Obtains the Features available within the given Rectangle.  Results are
// streamed rather than returned at once (e.g. in a response message with a
// repeated field), as the rectangle may cover a large area and contain a
// huge number of features.
rpc ListFeatures(Rectangle) returns (stream Feature) {}
</code></pre>

<ul>
<li>A <em>request-streaming RPC</em> where the client sends a sequence of messages to the
server. Once the client has finished writing the messages, it waits for the
server to read them all and return its response. You specify a
request-streaming method by placing the <code>stream</code> keyword before the <em>request</em>
type.</li>
</ul>

<pre><code class="language-protobuf">// Accepts a stream of Points on a route being traversed, returning a
// RouteSummary when traversal is completed.
rpc RecordRoute(stream Point) returns (RouteSummary) {}
</code></pre>

<ul>
<li>A <em>bidirectional streaming RPC</em> where both sides send a sequence of messages
to the other. The two streams operate independently, so clients and servers
can read and write in whatever order they like: for example, the server could
wait to receive all the client messages before writing its responses, or it
could alternately read a message then write a message, or some other
combination of reads and writes. The order of messages in each stream is
preserved. You specify this type of method by placing the <code>stream</code> keyword
before both the request and the response.</li>
</ul>

<pre><code class="language-protobuf">// Accepts a stream of RouteNotes sent while a route is being traversed,
// while receiving other RouteNotes (e.g. from other users).
rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
</code></pre>

<p>Our .proto file also contains protocol buffer message type definitions for all
the request and response types used in our service methods - for example, here&rsquo;s
the <code>Point</code> message type:</p>

<pre><code class="language-protobuf">// Points are represented as latitude-longitude pairs in the E7 representation
// (degrees multiplied by 10**7 and rounded to the nearest integer).
// Latitudes should be in the range +/- 90 degrees and longitude should be in
// the range +/- 180 degrees (inclusive).
message Point {
  int32 latitude = 1;
  int32 longitude = 2;
}
</code></pre>

<p>You can specify a prefix to be used for your generated classes by adding the
<code>objc_class_prefix</code> option at the top of the file. For example:</p>

<pre><code class="language-protobuf">option objc_class_prefix = &quot;RTG&quot;;
</code></pre>

<p><a name="protoc"></a></p>

<h2 id="generating-client-code">Generating client code</h2>

<p>Next we need to generate the gRPC client interfaces from our .proto service
definition. We do this using the protocol buffer compiler (<code>protoc</code>) with a
special gRPC Objective-C plugin.</p>

<p>For simplicity, we&rsquo;ve provided a <a href="https://github.com/grpc/grpc/blob/{{ site.data.config.grpc_release_tag }}/examples/objective-c/route_guide/RouteGuide.podspec">Podspec
file</a>
that runs <code>protoc</code> for you with the appropriate plugin, input, and output, and
describes how to compile the generated files. You just need to run in this
directory (<code>examples/objective-c/route_guide</code>):</p>

<pre><code>$ pod install
</code></pre>

<p>which, before installing the generated library in the XCode project of this sample, runs:</p>

<pre><code>$ protoc -I ../../protos --objc_out=Pods/RouteGuide --objcgrpc_out=Pods/RouteGuide ../../protos/route_guide.proto
</code></pre>

<p>Running this command generates the following files under <code>Pods/RouteGuide/</code>:</p>

<ul>
<li><code>RouteGuide.pbobjc.h</code>, the header which declares your generated message
classes.</li>
<li><code>RouteGuide.pbobjc.m</code>, which contains the implementation of your message
classes.</li>
<li><code>RouteGuide.pbrpc.h</code>, the header which declares your generated service
classes.</li>
<li><code>RouteGuide.pbrpc.m</code>, which contains the implementation of your service
classes.</li>
</ul>

<p>These contain:</p>

<ul>
<li>All the protocol buffer code to populate, serialize, and retrieve our request
and response message types.</li>
<li>A class called <code>RTGRouteGuide</code> that lets clients call the methods defined in
the <code>RouteGuide</code> service.</li>
</ul>

<p>You can also use the provided Podspec file to generate client code from any
other proto service definition; just replace the name (matching the file name),
version, and other metadata.</p>

<p><a name="client"></a></p>

<h2 id="creating-the-client-application">Creating the client application</h2>

<p>In this section, we&rsquo;ll look at creating an Objective-C client for our
<code>RouteGuide</code> service. You can see our complete example client code in
<a href="https://github.com/grpc/grpc/blob/{{ site.data.config.grpc_release_tag }}/examples/objective-c/route_guide/ViewControllers.m">examples/objective-c/route_guide/ViewControllers.m</a>.
(Note: In your apps, for maintainability and readability reasons, you shouldn&rsquo;t
put all of your view controllers in a single file; it&rsquo;s done here only to
simplify the learning process).</p>

<h3 id="constructing-a-service-object">Constructing a service object</h3>

<p>To call service methods, we first need to create a service object, an instance
of the generated <code>RTGRouteGuide</code> class. The designated initializer of the class
expects a <code>NSString *</code> with the server address and port we want to connect to:</p>

<pre><code>#import &lt;GRPCClient/GRPCCall+Tests.h&gt;
#import &lt;RouteGuide/RouteGuide.pbrpc.h&gt;

static NSString * const kHostAddress = @&quot;localhost:50051&quot;;
...
[GRPCCall useInsecureConnectionsForHost:kHostAddress];

RTGRouteGuide *service = [[RTGRouteGuide alloc] initWithHost:kHostAddress];
</code></pre>

<p>Notice that before constructing our service object we&rsquo;ve told the gRPC library
to use insecure connections for that host:port pair. This is because the server
we will be using to test our client doesn&rsquo;t use
<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS</a>. This is fine
because it will be running locally on our development machine. The most common
case, though, is connecting with a gRPC server on the internet, running gRPC
over TLS. For that case, the <code>useInsecureConnectionsForHost:</code> call isn&rsquo;t needed,
and the port defaults to 443 if absent.</p>

<h3 id="calling-service-methods">Calling service methods</h3>

<p>Now let&rsquo;s look at how we call our service methods. As you will see, all these
methods are asynchronous, so you can call them from the main thread of your app
without worrying about freezing your UI or the OS killing your app.</p>

<h4 id="simple-rpc">Simple RPC</h4>

<p>Calling the simple RPC <code>GetFeature</code> is as straightforward as calling any other
asynchronous method on Cocoa.</p>

<pre><code>RTGPoint *point = [RTGPoint message];
point.latitude = 40E7;
point.longitude = -74E7;

[service getFeatureWithRequest:point handler:^(RTGFeature *response, NSError *error) {
  if (response) {
    // Successful response received
  } else {
    // RPC error
  }
}];
</code></pre>

<p>As you can see, we create and populate a request protocol buffer object (in our
case <code>RTGPoint</code>). Then, we call the method on the service object, passing it the
request, and a block to handle the response (or any RPC error). If the RPC
finishes successfully, the handler block is called with a <code>nil</code> error argument,
and we can read the response information from the server from the response
argument. If, instead, some RPC error happens, the handler block is called with
a <code>nil</code> response argument, and we can read the details of the problem from the
error argument.</p>

<pre><code>NSLog(@&quot;Found feature called %@ at %@.&quot;, response.name, response.location);
</code></pre>

<h4 id="streaming-rpcs">Streaming RPCs</h4>

<p>Now let&rsquo;s look at our streaming methods. Here&rsquo;s where we call the
response-streaming method <code>ListFeatures</code>, which results in our client app
receiving a stream of geographical <code>RTGFeature</code>s:</p>

<pre><code>[service listFeaturesWithRequest:rectangle
                    eventHandler:^(BOOL done, RTGFeature *response, NSError *error) {
  if (response) {
    NSLog(@&quot;Found feature at %@ called %@.&quot;, response.location, response.name);
  } else if (error) {
    NSLog(@&quot;RPC error: %@&quot;, error);
  }
}];
</code></pre>

<p>Notice how the signature of the handler block now includes a <code>BOOL done</code>
parameter. The handler block can be called any number of times; only on the last
call is the <code>done</code> argument value set to <code>YES</code>. If an error occurs, the RPC
finishes and the handler is called with the arguments <code>(YES, nil, error)</code>.</p>

<p>The request-streaming method <code>RecordRoute</code> expects a stream of <code>RTGPoint</code>s from
the cient. This stream is passed to the method as an object that conforms to the
<code>GRXWriter</code> protocol. The simplest way to create one is to initialize one from a
<code>NSArray</code> object:</p>

<pre><code>#import &lt;gRPC/GRXWriter+Immediate.h&gt;

...

RTGPoint *point1 = [RTGPoint message];
point.latitude = 40E7;
point.longitude = -74E7;

RTGPoint *point2 = [RTGPoint message];
point.latitude = 40E7;
point.longitude = -74E7;

GRXWriter *locationsWriter = [GRXWriter writerWithContainer:@[point1, point2]];

[service recordRouteWithRequestsWriter:locationsWriter handler:^(RTGRouteSummary *response, NSError *error) {
  if (response) {
    NSLog(@&quot;Finished trip with %i points&quot;, response.pointCount);
    NSLog(@&quot;Passed %i features&quot;, response.featureCount);
    NSLog(@&quot;Travelled %i meters&quot;, response.distance);
    NSLog(@&quot;It took %i seconds&quot;, response.elapsedTime);
  } else {
    NSLog(@&quot;RPC error: %@&quot;, error);
  }
}];

</code></pre>

<p>The <code>GRXWriter</code> protocol is generic enough to allow for asynchronous streams, streams of future values, or even infinite streams.</p>

<p>Finally, let&rsquo;s look at our bidirectional streaming RPC <code>RouteChat()</code>. The way to
call a bidirectional streaming RPC is just a combination of how to call
request-streaming RPCs and response-streaming RPCs.</p>

<pre><code>[service routeChatWithRequestsWriter:notesWriter handler:^(BOOL done, RTGRouteNote *note, NSError *error) {
  if (note) {
    NSLog(@&quot;Got message %@ at %@&quot;, note.message, note.location);
  } else if (error) {
    NSLog(@&quot;RPC error: %@&quot;, error);
  }
  if (done) {
    NSLog(@&quot;Chat ended.&quot;);
  }
}];
</code></pre>

<p>The semantics for the handler block and the <code>GRXWriter</code> argument here are
exactly the same as for our request-streaming and response-streaming methods.
Although both client and server will always get the other&rsquo;s messages in the
order they were written, the two streams operate completely independently.</p>

</div>
</div>

</div>

    
    

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

  </body>
</html>
