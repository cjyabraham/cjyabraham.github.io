<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="https://cjyabraham.github.io/css/style.css">
    <title>
  gRPC Basics - Dart &ndash; gRPC
</title>
  </head>
  <body>

    <div id="landing-content">
      <div class="row">
        <div class="topbannersub">

	  <nav class="navbar navbar-expand-md navbar-dark topnav">
            <a class="navbar-brand" href="https://cjyabraham.github.io/">
                <img src="https://cjyabraham.github.io/img/grpc-logo.png" width="114" height="50">
            </a>
	    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
	      <span class="navbar-toggler-icon"></span>
	    </button>
            <div class="topnav, collapse navbar-collapse" id="navbarSupportedContent" style="float:right !important">
	      <ul class="navbar-nav ml-auto">
                <li class="nav-item ">
		  <a class="nav-link" href="https://cjyabraham.github.io/about/">About</a>
		</li>
                <li class="nav-item dropdown active">
		  <a class="nav-link dropdown-toggle" href="https://cjyabraham.github.io/docs/" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
		    Docs
		  </a>
		  <div class="dropdown-menu" aria-labelledby="navbarDropdown">
		    <a class="dropdown-item" href="https://cjyabraham.github.io/docs/">Overview</a>
		    <a class="dropdown-item" href="https://cjyabraham.github.io/docs/quickstart/">Quick Start</a>
		    <a class="dropdown-item" href="https://cjyabraham.github.io/docs/guides/">Guides</a>
		    <a class="dropdown-item" href="https://cjyabraham.github.io/docs/tutorials/">Tutorials</a>
		    <a class="dropdown-item" href="https://cjyabraham.github.io/docs/reference/">Reference</a>
		    <a class="dropdown-item" href="https://cjyabraham.github.io/docs/samples/">Samples</a>
		    <a class="dropdown-item" href="https://cjyabraham.github.io/docs/talks/">Presentations</a>
		  </div>
		</li>
                <li class="nav-item ">
		  <a class="nav-link" href="https://cjyabraham.github.io/blog/">Blog</a> 
		</li>
                <li class="nav-item ">
		  <a class="nav-link" href="https://cjyabraham.github.io/community/">Community</a>
		</li>
                <li class="nav-item">
		  <a class="nav-link" href="https://packages.grpc.io/">Packages</a> 
		</li>
                <li class="nav-item ">
		  <a class="nav-link" href="https://cjyabraham.github.io/faq/">FAQ</a>
		</li>
	      </ul>
            </div>
	  </nav>
    
            <div class="headertext">Documentation</div>
  </div>
        </div>
        </div>

    <div class="subnav d-none d-md-block">
  <a href="https://cjyabraham.github.io/docs/">Overview</a>
|  <a href="https://cjyabraham.github.io/docs/quickstart/">Quick Start</a>
|  <a href="https://cjyabraham.github.io/docs/guides/">Guides</a>
|  <a href="https://cjyabraham.github.io/docs/tutorials/"><div class="plusmain">+</div>Tutorials</a>
|  <a href="https://cjyabraham.github.io/docs/reference/">Reference</a>
|  <a href="https://cjyabraham.github.io/docs/samples/">Samples</a>
|  <a href="https://cjyabraham.github.io/docs/talks/">Presentations</a>
</div>


<div class="quickstartcols">

<div class="quickstartcol1">

<h8>Tutorials</h8>
<a href="https://cjyabraham.github.io/docs/tutorials/async/helloasync-cpp/">Async - C++</a>
<a href="https://cjyabraham.github.io/docs/tutorials/auth/oauth2-objective-c/">Auth - Objective C</a>
<h8>Basic</h8>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/c/">C++</a>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/csharp/">C#</a>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/dart/"><div class="plus">+</div>Dart</a>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/go/">Go</a>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/java/">Java</a>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/android/">Android Java</a>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/objective-c/">Objective-C</a>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/php/">PHP</a>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/python/">Python</a>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/ruby/">Ruby</a>

</div>

<div class="quickstartcol2" style="margin-top:4%">
<h3 style="margin-top:0px;">gRPC Basics - Dart</h3>

    

<p class="lead">This tutorial provides a basic Dart programmer's introduction to
working with gRPC.</p>

<p class="note">Dart gRPC is currently in beta. Please help us out by
<a href="https://github.com/grpc/grpc-dart/issues/new">filing issues</a>
if you encounter any.</p>

<p>By walking through this example you&rsquo;ll learn how to:</p>

<ul>
<li>Define a service in a .proto file.</li>
<li>Generate server and client code using the protocol buffer compiler.</li>
<li>Use the Dart gRPC API to write a simple client and server for your service.</li>
</ul>

<p>It assumes that you have read the <a href="/docs/index.html">Overview</a> and are familiar
with <a href="https://developers.google.com/protocol-buffers/docs/overview">protocol buffers</a>. Note that the
example in this tutorial uses the proto3 version of the protocol buffers
language, which is currently in beta release: you can find out more in the
<a href="https://developers.google.com/protocol-buffers/docs/proto3">proto3 language
guide</a>,
and see the <a href="https://github.com/google/protobuf/releases">release notes</a> for the
new version in the protocol buffers Github repository.</p>

<div id="toc"></div>

<h2 id="why-use-grpc">Why use gRPC?</h2>

<p>Our example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.</p>

<p>With gRPC we can define our service once in a .proto file and implement clients
and servers in any of gRPC&rsquo;s supported languages, which in turn can be run in
environments ranging from servers inside Google to your own tablet - all the
complexity of communication between different languages and environments is
handled for you by gRPC. We also get all the advantages of working with protocol
buffers, including efficient serialization, a simple IDL, and easy interface
updating.</p>

<h2 id="example-code-and-setup">Example code and setup</h2>

<p>The example code for our tutorial is in
<a href="https://github.com/grpc/grpc-dart/tree/master/example/route_guide">grpc/grpc-dart/example/route_guide</a>.
To download the example, clone the <code>grpc-dart</code> repository by running the following
command:</p>

<pre><code>$ git clone https://github.com/grpc/grpc-dart.git
</code></pre>

<p>Then change your current directory to <code>grpc-dart/example/route_guide</code>:</p>

<pre><code>$ cd grpc-dart/example/route_guide
</code></pre>

<p>You also should have the relevant tools installed to generate the server and client interface code - if you don&rsquo;t already, follow the setup instructions in <a href="/docs/quickstart/dart.html">the Dart quick start guide</a>.</p>

<h2 id="defining-the-service">Defining the service</h2>

<p>Our first step (as you&rsquo;ll know from the <a href="/docs/index.html">Overview</a>) is to
define the gRPC <em>service</em> and the method <em>request</em> and <em>response</em> types using
<a href="https://developers.google.com/protocol-buffers/docs/overview">protocol buffers</a>. You can see the
complete .proto file in
<a href="https://github.com/grpc/grpc-dart/blob/master/example/route_guide/protos/route_guide.proto"><code>example/route_guide/protos/route_guide.proto</code></a>.</p>

<p>To define a service, you specify a named <code>service</code> in your .proto file:</p>

<pre><code class="language-proto">service RouteGuide {
   ...
}
</code></pre>

<p>Then you define <code>rpc</code> methods inside your service definition, specifying their
request and response types. gRPC lets you define four kinds of service method,
all of which are used in the <code>RouteGuide</code> service:</p>

<ul>
<li>A <em>simple RPC</em> where the client sends a request to the server using the stub
and waits for a response to come back, just like a normal function call.</li>
</ul>

<pre><code class="language-proto">// Obtains the feature at a given position.
rpc GetFeature(Point) returns (Feature) {}
</code></pre>

<ul>
<li>A <em>server-side streaming RPC</em> where the client sends a request to the server
and gets a stream to read a sequence of messages back. The client reads from
the returned stream until there are no more messages. As you can see in our
example, you specify a server-side streaming method by placing the <code>stream</code>
keyword before the <em>response</em> type.</li>
</ul>

<pre><code class="language-proto">// Obtains the Features available within the given Rectangle.  Results are
// streamed rather than returned at once (e.g. in a response message with a
// repeated field), as the rectangle may cover a large area and contain a
// huge number of features.
rpc ListFeatures(Rectangle) returns (stream Feature) {}
</code></pre>

<ul>
<li>A <em>client-side streaming RPC</em> where the client writes a sequence of messages
and sends them to the server, again using a provided stream. Once the client
has finished writing the messages, it waits for the server to read them all
and return its response. You specify a client-side streaming method by placing
the <code>stream</code> keyword before the <em>request</em> type.</li>
</ul>

<pre><code class="language-proto">// Accepts a stream of Points on a route being traversed, returning a
// RouteSummary when traversal is completed.
rpc RecordRoute(stream Point) returns (RouteSummary) {}
</code></pre>

<ul>
<li>A <em>bidirectional streaming RPC</em> where both sides send a sequence of messages
using a read-write stream. The two streams operate independently, so clients
and servers can read and write in whatever order they like: for example, the
server could wait to receive all the client messages before writing its
responses, or it could alternately read a message then write a message, or
some other combination of reads and writes. The order of messages in each
stream is preserved. You specify this type of method by placing the <code>stream</code>
keyword before both the request and the response.</li>
</ul>

<pre><code class="language-proto">// Accepts a stream of RouteNotes sent while a route is being traversed,
// while receiving other RouteNotes (e.g. from other users).
rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
</code></pre>

<p>Our .proto file also contains protocol buffer message type definitions for all the request and response types used in our service methods - for example, here&rsquo;s the <code>Point</code> message type:</p>

<pre><code class="language-proto">// Points are represented as latitude-longitude pairs in the E7 representation
// (degrees multiplied by 10**7 and rounded to the nearest integer).
// Latitudes should be in the range +/- 90 degrees and longitude should be in
// the range +/- 180 degrees (inclusive).
message Point {
  int32 latitude = 1;
  int32 longitude = 2;
}
</code></pre>

<h2 id="generating-client-and-server-code">Generating client and server code</h2>

<p>Next we need to generate the gRPC client and server interfaces from our .proto
service definition. We do this using the protocol buffer compiler <code>protoc</code> with
a special Dart plugin.
This is similar to what we did in the <a href="../../quickstart/dart.html">quickstart guide</a></p>

<p>From the <code>route_guide</code> example directory run :</p>

<pre><code class="language-sh"> protoc -I protos/ protos/route_guide.proto --dart_out=grpc:lib/src/generated
</code></pre>

<p>Running this command generates the following files in the <code>lib/src/generated</code>
directory under the <code>route_guide</code> example directory:</p>

<ul>
<li><code>route_guide.pb.dart</code></li>
<li><code>route_guide.pbenum.dart</code></li>
<li><code>route_guide.pbgrpc.dart</code></li>
<li><code>route_guide.pbjson.dart</code></li>
</ul>

<p>This contains:</p>

<ul>
<li>All the protocol buffer code to populate, serialize, and retrieve our request
and response message types</li>
<li>An interface type (or <em>stub</em>) for clients to call with the methods defined in
the <code>RouteGuide</code> service.</li>
<li>An interface type for servers to implement, also with the methods defined in
the <code>RouteGuide</code> service.</li>
</ul>

<p><a name="server"></a></p>

<h2 id="creating-the-server">Creating the server</h2>

<p>First let&rsquo;s look at how we create a <code>RouteGuide</code> server. If you&rsquo;re only
interested in creating gRPC clients, you can skip this section and go straight
to <a href="#client">Creating the client</a> (though you might find it interesting
anyway!).</p>

<p>There are two parts to making our <code>RouteGuide</code> service do its job:</p>

<ul>
<li>Implementing the service interface generated from our service definition:
doing the actual &ldquo;work&rdquo; of our service.</li>
<li>Running a gRPC server to listen for requests from clients and dispatch them to
the right service implementation.</li>
</ul>

<p>You can find our example <code>RouteGuide</code> server in
<a href="https://github.com/grpc/grpc-dart/tree/master/example/route_guide/lib/src/server.dart">grpc-dart/example/route_guide/lib/src/server.dart</a>.
Let&rsquo;s take a closer look at how it works.</p>

<h3 id="implementing-routeguide">Implementing RouteGuide</h3>

<p>As you can see, our server has a <code>RouteGuideService</code> class that extends the
generated abstract <code>RouteGuideServiceBase</code> class:</p>

<pre><code class="language-dart">class RouteGuideService extends RouteGuideServiceBase {
  Future&lt;Feature&gt; getFeature(grpc.ServiceCall call, Point request) async {
    ...
  }

  Stream&lt;Feature&gt; listFeatures(
      grpc.ServiceCall call, Rectangle request) async* {
    ...
  }

  Future&lt;RouteSummary&gt; recordRoute(
      grpc.ServiceCall call, Stream&lt;Point&gt; request) async {
    ...
  }

  Stream&lt;RouteNote&gt; routeChat(
      grpc.ServiceCall call, Stream&lt;RouteNote&gt; request) async* {
    ...
  }

  ...
}
</code></pre>

<h4 id="simple-rpc">Simple RPC</h4>

<p><code>RouteGuideService</code> implements all our service methods. Let&rsquo;s look at the
simplest type first, <code>GetFeature</code>, which just gets a <code>Point</code> from the client and
returns the corresponding feature information from its database in a <code>Feature</code>.</p>

<pre><code class="language-dart">/// GetFeature handler. Returns a feature for the given location.
/// The [context] object provides access to client metadata, cancellation, etc.
@override
Future&lt;Feature&gt; getFeature(grpc.ServiceCall call, Point request) async {
  return featuresDb.firstWhere((f) =&gt; f.location == request,
      orElse: () =&gt; new Feature()..location = request);
}
</code></pre>

<p>The method is passed a context object for the RPC and the client&rsquo;s <code>Point</code>
protocol buffer request. It returns a <code>Feature</code> protocol buffer object with the
response information. In the method we populate the <code>Feature</code> with the appropriate
information, and then <code>return</code> it to the gRPC framework, which sends it back to
the client.</p>

<h4 id="server-side-streaming-rpc">Server-side streaming RPC</h4>

<p>Now let&rsquo;s look at one of our streaming RPCs. <code>ListFeatures</code> is a server-side
streaming RPC, so we need to send back multiple <code>Feature</code>s to our client.</p>

<pre><code class="language-dart">/// ListFeatures handler. Returns a stream of features within the given
/// rectangle.
@override
Stream&lt;Feature&gt; listFeatures(
    grpc.ServiceCall call, Rectangle request) async* {
  final normalizedRectangle = _normalize(request);
  // For each feature, check if it is in the given bounding box
  for (var feature in featuresDb) {
    if (feature.name.isEmpty) continue;
    final location = feature.location;
    if (_contains(normalizedRectangle, location)) {
      yield feature;
    }
  }
}
</code></pre>

<p>As you can see, instead of getting and returning simple request and response
objects in our method, this time we get a request object (the <code>Rectangle</code> in
which our client wants to find <code>Feature</code>s) and return a <code>Stream</code> of <code>Feature</code>
objects.</p>

<p>In the method, we populate as many <code>Feature</code> objects as we need to return,
adding them to the returned stream using <code>yield</code>. The stream is automatically
closed when the method returns, telling gRPC that we have finished writing
responses.</p>

<p>Should any error happen in this call, the error will be added as an exception
to the stream, and the gRPC layer will translate it into an appropriate RPC
status to be sent on the wire.</p>

<h4 id="client-side-streaming-rpc">Client-side streaming RPC</h4>

<p>Now let&rsquo;s look at something a little more complicated: the client-side
streaming method <code>RecordRoute</code>, where we get a stream of <code>Point</code>s from the
client and return a single <code>RouteSummary</code> with information about their trip. As
you can see, this time the request parameter is a stream, which the server can
use to both read request messages from the client. The server returns its single
response just like in the simple RPC case.</p>

<pre><code class="language-dart">/// RecordRoute handler. Gets a stream of points, and responds with statistics
/// about the &quot;trip&quot;: number of points, number of known features visited,
/// total distance traveled, and total time spent.
@override
Future&lt;RouteSummary&gt; recordRoute(
    grpc.ServiceCall call, Stream&lt;Point&gt; request) async {
  int pointCount = 0;
  int featureCount = 0;
  double distance = 0.0;
  Point previous;
  final timer = new Stopwatch();

  await for (var location in request) {
    if (!timer.isRunning) timer.start();
    pointCount++;
    final feature = featuresDb.firstWhere((f) =&gt; f.location == location,
        orElse: () =&gt; null);
    if (feature != null) {
      featureCount++;
    }
    // For each point after the first, add the incremental distance from the
    // previous point to the total distance value.
    if (previous != null) distance += _distance(previous, location);
    previous = location;
  }
  timer.stop();
  return new RouteSummary()
    ..pointCount = pointCount
    ..featureCount = featureCount
    ..distance = distance.round()
    ..elapsedTime = timer.elapsed.inSeconds;
}
</code></pre>

<p>In the method body we use <code>await for</code> in the request stream to repeatedly read
in our client&rsquo;s requests (in this case <code>Point</code> objects) until there are no more
messages. Once the request stream is done, the server can return its
<code>RouteSummary</code>.</p>

<h4 id="bidirectional-streaming-rpc">Bidirectional streaming RPC</h4>

<p>Finally, let&rsquo;s look at our bidirectional streaming RPC <code>RouteChat()</code>.</p>

<pre><code class="language-dart">/// RouteChat handler. Receives a stream of message/location pairs, and
/// responds with a stream of all previous messages at each of those
/// locations.
@override
Stream&lt;RouteNote&gt; routeChat(
    grpc.ServiceCall call, Stream&lt;RouteNote&gt; request) async* {
  await for (var note in request) {
    final notes = routeNotes.putIfAbsent(note.location, () =&gt; &lt;RouteNote&gt;[]);
    for (var note in notes) yield note;
    notes.add(note);
  }
}
</code></pre>

<p>This time we get a stream of <code>RouteNote</code> that, as in our client-side streaming
example, can be used to read messages. However, this time we return values via
our method&rsquo;s returned stream while the client is still writing messages to
<em>their</em> message stream.</p>

<p>The syntax for reading and writing here is the same as our client-streaming and
server-streaming methods. Although each side will always get the other&rsquo;s messages
in the order they were written, both the client and server can read and write in
any order — the streams operate completely independently.</p>

<h3 id="starting-the-server">Starting the server</h3>

<p>Once we&rsquo;ve implemented all our methods, we also need to start up a gRPC server
so that clients can actually use our service. The following snippet shows how we
do this for our <code>RouteGuide</code> service:</p>

<pre><code class="language-dart">Future&lt;Null&gt; main(List&lt;String&gt; args) async {
  final server =
      new grpc.Server([new RouteGuideService()]);
  await server.serve(port: 8080);
  print('Server listening...');
}
</code></pre>

<p>To build and start a server, we:</p>

<ol>
<li>Create an instance of the gRPC server using <code>new grpc.Server()</code>,
giving a list of service implementations.</li>
<li>Call <code>serve()</code> on the server to start listening for requests, optionally passing
in the address and port to listen on. The server will continue to serve requests
asynchronously until <code>shutdown()</code> is called on it.</li>
</ol>

<p><a name="client"></a></p>

<h2 id="creating-the-client">Creating the client</h2>

<p>In this section, we&rsquo;ll look at creating a Dart client for our <code>RouteGuide</code>
service. You can see our complete example client code in
<a href="https://github.com/grpc/grpc-dart/tree/master/example/route_guide/lib/src/client.dart">grpc-dart/example/route_guide/lib/src/client.dart</a>.</p>

<h3 id="creating-a-stub">Creating a stub</h3>

<p>To call service methods, we first need to create a gRPC <em>channel</em> to communicate
with the server. We create this by passing the server address and port number to
<code>new ClientChannel()</code> as follows:</p>

<pre><code class="language-dart">final channel = new ClientChannel('127.0.0.1',
    port: 8080,
    options: const ChannelOptions(
        credentials: const ChannelCredentials.insecure()));
</code></pre>

<p>You can use <code>ChannelOptions</code> to set TLS options (e.g., trusted certificates) for
the channel, if necessary.</p>

<p>Once the gRPC <em>channel</em> is setup, we need a client <em>stub</em> to perform RPCs. We
get by creating a new instance of the <code>RouteGuideClient</code> object provided in the
package we generated from our .proto.</p>

<pre><code class="language-dart">final client = new RouteGuideClient(channel,
    options: new CallOptions(timeout: new Duration(seconds: 30)));
</code></pre>

<p>You can use <code>CallOptions</code> to set the auth credentials (e.g., GCE credentials,
JWT credentials) if the service you request requires that - however, we don&rsquo;t
need to do this for our <code>RouteGuide</code> service.</p>

<h3 id="calling-service-methods">Calling service methods</h3>

<p>Now let&rsquo;s look at how we call our service methods. Note that in gRPC-Dart, RPCs
are always asynchronous, which means that the RPC returns a <code>Future</code> or <code>Stream</code>
that must be listened to, to get the response from the server or an error.</p>

<h4 id="simple-rpc-1">Simple RPC</h4>

<p>Calling the simple RPC <code>GetFeature</code> is nearly as straightforward as calling a
local method.</p>

<pre><code class="language-dart">final point = new Point()
  ..latitude = 409146138
  ..longitude = -746188906;
final feature = await stub.getFeature(point));
</code></pre>

<p>As you can see, we call the method on the stub we got earlier. In our method
parameters we pass a request protocol buffer object (in our case <code>Point</code>).
We can also pass an optional <code>CallOptions</code> object which lets us change our RPC&rsquo;s
behaviour if necessary, such as time-out. If the call doesn&rsquo;t return an error,
the returned <code>Future</code> completes with the response information from the server.
If there is an error, the <code>Future</code> will complete with the error.</p>

<h4 id="server-side-streaming-rpc-1">Server-side streaming RPC</h4>

<p>Here&rsquo;s where we call the server-side streaming method <code>ListFeatures</code>, which
returns a stream of geographical <code>Feature</code>s. If you&rsquo;ve already read <a href="#server">Creating
the server</a> some of this may look very familiar - streaming RPCs are
implemented in a similar way on both sides.</p>

<pre><code class="language-dart">final rect = new Rectangle()...; // initialize a Rectangle

try {
  await for (var feature in stub.listFeatures(rect)) {
    print(feature);
  }
catch (e) {
  print('ERROR: $e');
}
</code></pre>

<p>As in the simple RPC, we pass the method a request. However, instead of getting
a <code>Future</code> back, we get a <code>Stream</code>. The client can use the stream to read the
server&rsquo;s responses.</p>

<p>We use <code>await for</code> on the returned stream to repeatedly read in the server&rsquo;s
responses to a response protocol buffer object (in this case a <code>Feature</code>) until
there are no more messages.</p>

<h4 id="client-side-streaming-rpc-1">Client-side streaming RPC</h4>

<p>The client-side streaming method <code>RecordRoute</code> is similar to the server-side
method, except that we pass the method a <code>Stream</code> and get a <code>Future</code> back.</p>

<pre><code class="language-dart">final random = new Random();

// Generate a number of random points
Stream&lt;Point&gt; generateRoute(int count) async* {
  for (int i = 0; i &lt; count; i++) {
    final point = featuresDb[random.nextInt(featuresDb.length)].location;
    yield point;
  }
}

final pointCount = random.nextInt(100) + 2; // Traverse at least two points

final summary = await stub.recordRoute(generateRoute(pointCount));
print('Route summary: $summary');
</code></pre>

<p>Since the <code>generateRoute()</code> method is <code>async*</code>, the points will be generated when
gRPC listens to the request stream and sends the point messages to the server. Once
the stream is done (when <code>generateRoute()</code> returns), gRPC knows that we&rsquo;ve finished
writing and are expecting to receive a response. The returned <code>Future</code> will either
complete with the <code>RouteSummary</code> message received from the server, or an error.</p>

<h4 id="bidirectional-streaming-rpc-1">Bidirectional streaming RPC</h4>

<p>Finally, let&rsquo;s look at our bidirectional streaming RPC <code>RouteChat()</code>. As in the
case of <code>RecordRoute</code>, we pass the method a stream where we will write the request
messages, and like in <code>ListFeatures</code>, we get back a stream that we can use to read
the response messages. However, this time we will send values via our method&rsquo;s stream
while the server is also writing messages to <em>their</em> message stream.</p>

<pre><code class="language-dart">Stream&lt;RouteNote&gt; outgoingNotes = ...;

final responses = stub.routeChat(outgoingNotes);
await for (var note in responses) {
  print('Got message ${note.message} at ${note.location.latitude}, ${note
      .location.longitude}');
}
</code></pre>

<p>The syntax for reading and writing here is very similar to our client-side and
server-side streaming methods. Although each side will always get the other&rsquo;s
messages in the order they were written, both the client and server can read and
write in any order — the streams operate completely independently.</p>

<h2 id="try-it-out">Try it out!</h2>

<p>Go to the <code>examples/route_guide</code> folder.</p>

<p>First, make sure dependencies are downloaded:</p>

<pre><code class="language-sh">$ pub get
</code></pre>

<p>To run the server, simply:</p>

<pre><code class="language-sh">$ dart bin/server.dart
</code></pre>

<p>Likewise, to run the client:</p>

<pre><code class="language-sh">$ dart bin/client.dart
</code></pre>

</div>
</div>

</div>

    
    

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

  </body>
</html>
