<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="https://cjyabraham.github.io/css/style.css">
    <title>
   &ndash; gRPC
</title>
  </head>
  <body>

    <div id="landing-content">
      <div class="row">
        <div class="topbannersub">
          <div class="logonav">
                <img src="https://cjyabraham.github.io/img/grpc-logo.png" style="width:10%">
            </div>
            <div class="topnav">
                <a href="https://cjyabraham.github.io/about/">About</a>
		<a href="https://cjyabraham.github.io/docs/">Docs</a>
		<a href="https://cjyabraham.github.io/blog/">Blog</a> 
		<a href="https://cjyabraham.github.io/community/">Community</a>
		<a href="https://packages.grpc.io/">Packages</a> 
		<a href="https://cjyabraham.github.io/faq/">FAQ</a>
            </div>
    
            <div class="headertext"></div>
  </div>
        </div>
        </div>

  <div class="section2" style="text-align:left;margin-bottom:5%">
    

<p class="lead">This guide gets you started with gRPC in C++ with a simple
working example.</p>

<div id="toc"></div>

<h2 id="before-you-begin">Before you begin</h2>

<h3 id="prerequisites">Prerequisites</h3>

<h4 id="install-grpc">Install gRPC</h4>

<p>To install gRPC on your system, follow the <a href="https://github.com/grpc/grpc/blob/master/src/cpp/README.md#make">instructions to install gRPC C++ via make</a>.</p>

<p>To run the example code, please ensure <code>pkg-config</code> is installed on your
machine before you build and install gRPC in the previous step, since the
example <code>Makefile</code>s try to look up the installed gRPC path using <code>pkg-config</code>.
On Debian-based systems like Ubuntu, this can usually be done via
<code>sudo apt-get install pkg-config</code>.</p>

<h4 id="install-protocol-buffers-v3">Install Protocol Buffers v3</h4>

<p>While not mandatory to use gRPC, gRPC applications usually leverage Protocol
Buffers v3 for service definitions and data serialization, and our example code
uses Protocol Buffers as well as gRPC. If you don&rsquo;t already have it installed on
your system, you can install the version cloned alongside gRPC. First ensure
that you are running these commands in the gRPC tree you just built in the from
the previous step.</p>

<pre><code class="language-sh">$ cd third_party/protobuf
$ make &amp;&amp; sudo make install
</code></pre>

<h2 id="build-the-example">Build the example</h2>

<p>Always assuming you have gRPC properly installed, go into the example&rsquo;s
directory:</p>

<pre><code class="language-sh">$ cd examples/cpp/helloworld/
</code></pre>

<p>Let&rsquo;s build the example client and server:</p>

<pre><code class="language-sh">$ make
</code></pre>

<p>Most failures at this point are a result of a faulty installation (or having
installed gRPC to a non-standard location. Check out <a href="https://github.com/grpc/grpc/blob/master/src/cpp/README.md#make">the installation
instructions for details</a>).</p>

<h2 id="try-it">Try it!</h2>

<p>From the <code>examples/cpp/helloworld</code> directory, run the server, which will listen
on port 50051:</p>

<pre><code class="language-sh">$ ./greeter_server
</code></pre>

<p>From a different terminal, run the client:</p>

<pre><code class="language-sh">$ ./greeter_client
</code></pre>

<p>If things go smoothly, you will see the <code>Greeter received: Hello world</code> in the
client side output.</p>

<p>Congratulations! You&rsquo;ve just run a client-server application with gRPC.</p>

<h2 id="update-a-grpc-service">Update a gRPC service</h2>

<p>Now let&rsquo;s look at how to update the application with an extra method on the
server for the client to call. Our gRPC service is defined using protocol
buffers; you can find out lots more about how to define a service in a <code>.proto</code>
file in <a href="/docs/#what-is-grpc">What is gRPC?</a> and <a href="../tutorials/basic/c.html">gRPC Basics:
C++</a>. For now all you need to know is that both the server and the client
&ldquo;stub&rdquo; have a <code>SayHello</code> RPC method that takes a <code>HelloRequest</code> parameter from
the client and returns a <code>HelloResponse</code> from the server, and that this method
is defined like this:</p>

<pre><code class="language-protobuf">// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
</code></pre>

<p>Let&rsquo;s update this so that the <code>Greeter</code> service has two methods. Edit
<code>examples/protos/helloworld.proto</code> (from the root of the cloned repository) and
update it with a new <code>SayHelloAgain</code> method, with the same request and response
types:</p>

<pre><code class="language-protobuf">// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
  // Sends another greeting
  rpc SayHelloAgain (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
</code></pre>

<p>(Don&rsquo;t forget to save the file!)</p>

<h2 id="generate-grpc-code">Generate gRPC code</h2>

<p>Next we need to update the gRPC code used by our application to use the new
service definition. From the <code>examples/cpp/helloworld</code> directory:</p>

<pre><code class="language-sh">$ make
</code></pre>

<p>This regenerates <code>helloworld.pb.{h,cc}</code> and <code>helloworld.grpc.pb.{h,cc}</code>, which
contains our generated client and server classes, as well as classes for
populating, serializing, and retrieving our request and response types.</p>

<h2 id="update-and-run-the-application">Update and run the application</h2>

<p>We now have new generated server and client code, but we still need to implement
and call the new method in the human-written parts of our example application.</p>

<h3 id="update-the-server">Update the server</h3>

<p>In the same directory, open <code>greeter_server.cc</code>. Implement the new method like
this:</p>

<pre><code>class GreeterServiceImpl final : public Greeter::Service {
  Status SayHello(ServerContext* context, const HelloRequest* request,
                  HelloReply* reply) override {
     // ... (pre-existing code)
  }

  Status SayHelloAgain(ServerContext* context, const HelloRequest* request,
                       HelloReply* reply) override {
    std::string prefix(&quot;Hello again &quot;);
    reply-&gt;set_message(prefix + request-&gt;name());
    return Status::OK;
  }
};

</code></pre>

<h3 id="update-the-client">Update the client</h3>

<p>A new <code>SayHelloAgain</code> method is now available in the stub. We&rsquo;ll follow the same
pattern as for the already present <code>SayHello</code> and add a new <code>SayHelloAgain</code>
method to <code>GreeterClient</code>:</p>

<pre><code>class GreeterClient {
 public:
  // ...
  std::string SayHello(const std::string&amp; user) {
     // ...
  }

  std::string SayHelloAgain(const std::string&amp; user) {
    // Follows the same pattern as SayHello.
    HelloRequest request;
    request.set_name(user);
    HelloReply reply;
    ClientContext context;

    // Here we can the stub's newly available method we just added.
    Status status = stub_-&gt;SayHelloAgain(&amp;context, request, &amp;reply);
    if (status.ok()) {
      return reply.message();
    } else {
      std::cout &lt;&lt; status.error_code() &lt;&lt; &quot;: &quot; &lt;&lt; status.error_message()
                &lt;&lt; std::endl;
      return &quot;RPC failed&quot;;
    }
  }

</code></pre>

<p>Finally, we exercise this new method in <code>main</code>:</p>

<pre><code>int main(int argc, char** argv) {
  // ...
  std::string reply = greeter.SayHello(user);
  std::cout &lt;&lt; &quot;Greeter received: &quot; &lt;&lt; reply &lt;&lt; std::endl;

  reply = greeter.SayHelloAgain(user);
  std::cout &lt;&lt; &quot;Greeter received: &quot; &lt;&lt; reply &lt;&lt; std::endl;

  return 0;
}

</code></pre>

<h3 id="run">Run!</h3>

<p>Just like we did before, from the <code>examples/cpp/helloworld</code> directory:</p>

<ol>
<li><p>Build the client and server after having made changes:</p>

<pre><code class="language-sh">$ make
</code></pre></li>

<li><p>Run the server</p></li>
</ol>

<pre><code class="language-sh">   $ ./greeter_server
</code></pre>

<ol>
<li>On a different terminal, run the client</li>
</ol>

<pre><code class="language-sh">   $ ./greeter_client
</code></pre>

<p>You should see the updated output:</p>

<pre><code>   $ ./greeter_client
   Greeter received: Hello world
   Greeter received: Hello again world
</code></pre>

<h2 id="what-s-next">What&rsquo;s next</h2>

<ul>
<li>Read a full explanation of how gRPC works in <a href="../guides/">What is gRPC?</a>
and <a href="../guides/concepts.html">gRPC Concepts</a></li>
<li>Work through a more detailed tutorial in <a href="../tutorials/basic/c.html">gRPC Basics: C++</a></li>
<li>Explore the gRPC C++ core API in its <a href="/grpc/cpp/">reference
documentation</a></li>
</ul>

  </div>

    
    
  </body>
</html>
